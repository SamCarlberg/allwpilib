// Copyright (c) FIRST and other WPILib contributors.
// Open Source Software; you can modify and/or share it under the terms of
// the WPILib BSD license file in the root directory of this project.

// Code generated by protocol buffer compiler. Do not edit!
package org.wpilib.commands3.proto;

import java.io.IOException;
import us.hebi.quickbuf.Descriptors;
import us.hebi.quickbuf.FieldName;
import us.hebi.quickbuf.InvalidProtocolBufferException;
import us.hebi.quickbuf.JsonSink;
import us.hebi.quickbuf.JsonSource;
import us.hebi.quickbuf.MessageFactory;
import us.hebi.quickbuf.ProtoMessage;
import us.hebi.quickbuf.ProtoSink;
import us.hebi.quickbuf.ProtoSource;
import us.hebi.quickbuf.ProtoUtil;
import us.hebi.quickbuf.RepeatedMessage;

/** Protobuf type {@code ProtobufScheduler} */
@SuppressWarnings("hiding")
public final class ProtobufScheduler extends ProtoMessage<ProtobufScheduler> implements Cloneable {
  private static final long serialVersionUID = 0L;

  /**
   *
   *
   * <pre>
   *  How much time the scheduler took in its last `run()` invocation.
   * </pre>
   *
   * <code>optional double last_time_ms = 3;</code>
   */
  private double lastTimeMs;

  /**
   *
   *
   * <pre>
   *  Note: commands are generally queued by triggers, which occurs immediately before they are
   *  promoted and start running. Entries will only appear here when serializing a scheduler
   *  _after_ manually scheduling a command but _before_ calling scheduler.run()
   * </pre>
   *
   * <code>repeated .wpi.proto.ProtobufCommand queued_commands = 1;</code>
   */
  private final RepeatedMessage<ProtobufCommand> queuedCommands =
      RepeatedMessage.newEmptyInstance(ProtobufCommand.getFactory());

  /** <code>repeated .wpi.proto.ProtobufCommand running_commands = 2;</code> */
  private final RepeatedMessage<ProtobufCommand> runningCommands =
      RepeatedMessage.newEmptyInstance(ProtobufCommand.getFactory());

  private ProtobufScheduler() {}

  /**
   * @return a new empty instance of {@code ProtobufScheduler}
   */
  public static ProtobufScheduler newInstance() {
    return new ProtobufScheduler();
  }

  /**
   *
   *
   * <pre>
   *  How much time the scheduler took in its last `run()` invocation.
   * </pre>
   *
   * <code>optional double last_time_ms = 3;</code>
   *
   * @return whether the lastTimeMs field is set
   */
  public boolean hasLastTimeMs() {
    return (bitField0_ & 0x00000001) != 0;
  }

  /**
   *
   *
   * <pre>
   *  How much time the scheduler took in its last `run()` invocation.
   * </pre>
   *
   * <code>optional double last_time_ms = 3;</code>
   *
   * @return this
   */
  public ProtobufScheduler clearLastTimeMs() {
    bitField0_ &= ~0x00000001;
    lastTimeMs = 0D;
    return this;
  }

  /**
   *
   *
   * <pre>
   *  How much time the scheduler took in its last `run()` invocation.
   * </pre>
   *
   * <code>optional double last_time_ms = 3;</code>
   *
   * @return the lastTimeMs
   */
  public double getLastTimeMs() {
    return lastTimeMs;
  }

  /**
   *
   *
   * <pre>
   *  How much time the scheduler took in its last `run()` invocation.
   * </pre>
   *
   * <code>optional double last_time_ms = 3;</code>
   *
   * @param value the lastTimeMs to set
   * @return this
   */
  public ProtobufScheduler setLastTimeMs(final double value) {
    bitField0_ |= 0x00000001;
    lastTimeMs = value;
    return this;
  }

  /**
   *
   *
   * <pre>
   *  Note: commands are generally queued by triggers, which occurs immediately before they are
   *  promoted and start running. Entries will only appear here when serializing a scheduler
   *  _after_ manually scheduling a command but _before_ calling scheduler.run()
   * </pre>
   *
   * <code>repeated .wpi.proto.ProtobufCommand queued_commands = 1;</code>
   *
   * @return whether the queuedCommands field is set
   */
  public boolean hasQueuedCommands() {
    return (bitField0_ & 0x00000002) != 0;
  }

  /**
   *
   *
   * <pre>
   *  Note: commands are generally queued by triggers, which occurs immediately before they are
   *  promoted and start running. Entries will only appear here when serializing a scheduler
   *  _after_ manually scheduling a command but _before_ calling scheduler.run()
   * </pre>
   *
   * <code>repeated .wpi.proto.ProtobufCommand queued_commands = 1;</code>
   *
   * @return this
   */
  public ProtobufScheduler clearQueuedCommands() {
    bitField0_ &= ~0x00000002;
    queuedCommands.clear();
    return this;
  }

  /**
   *
   *
   * <pre>
   *  Note: commands are generally queued by triggers, which occurs immediately before they are
   *  promoted and start running. Entries will only appear here when serializing a scheduler
   *  _after_ manually scheduling a command but _before_ calling scheduler.run()
   * </pre>
   *
   * <code>repeated .wpi.proto.ProtobufCommand queued_commands = 1;</code> This method returns the
   * internal storage object without modifying any has state. The returned object should not be
   * modified and be treated as read-only.
   *
   * <p>Use {@link #getMutableQueuedCommands()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RepeatedMessage<ProtobufCommand> getQueuedCommands() {
    return queuedCommands;
  }

  /**
   *
   *
   * <pre>
   *  Note: commands are generally queued by triggers, which occurs immediately before they are
   *  promoted and start running. Entries will only appear here when serializing a scheduler
   *  _after_ manually scheduling a command but _before_ calling scheduler.run()
   * </pre>
   *
   * <code>repeated .wpi.proto.ProtobufCommand queued_commands = 1;</code> This method returns the
   * internal storage object and sets the corresponding has state. The returned object will become
   * part of this message and its contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RepeatedMessage<ProtobufCommand> getMutableQueuedCommands() {
    bitField0_ |= 0x00000002;
    return queuedCommands;
  }

  /**
   *
   *
   * <pre>
   *  Note: commands are generally queued by triggers, which occurs immediately before they are
   *  promoted and start running. Entries will only appear here when serializing a scheduler
   *  _after_ manually scheduling a command but _before_ calling scheduler.run()
   * </pre>
   *
   * <code>repeated .wpi.proto.ProtobufCommand queued_commands = 1;</code>
   *
   * @param value the queuedCommands to add
   * @return this
   */
  public ProtobufScheduler addQueuedCommands(final ProtobufCommand value) {
    bitField0_ |= 0x00000002;
    queuedCommands.add(value);
    return this;
  }

  /**
   *
   *
   * <pre>
   *  Note: commands are generally queued by triggers, which occurs immediately before they are
   *  promoted and start running. Entries will only appear here when serializing a scheduler
   *  _after_ manually scheduling a command but _before_ calling scheduler.run()
   * </pre>
   *
   * <code>repeated .wpi.proto.ProtobufCommand queued_commands = 1;</code>
   *
   * @param values the queuedCommands to add
   * @return this
   */
  public ProtobufScheduler addAllQueuedCommands(final ProtobufCommand... values) {
    bitField0_ |= 0x00000002;
    queuedCommands.addAll(values);
    return this;
  }

  /**
   * <code>repeated .wpi.proto.ProtobufCommand running_commands = 2;</code>
   *
   * @return whether the runningCommands field is set
   */
  public boolean hasRunningCommands() {
    return (bitField0_ & 0x00000004) != 0;
  }

  /**
   * <code>repeated .wpi.proto.ProtobufCommand running_commands = 2;</code>
   *
   * @return this
   */
  public ProtobufScheduler clearRunningCommands() {
    bitField0_ &= ~0x00000004;
    runningCommands.clear();
    return this;
  }

  /**
   * <code>repeated .wpi.proto.ProtobufCommand running_commands = 2;</code> This method returns the
   * internal storage object without modifying any has state. The returned object should not be
   * modified and be treated as read-only.
   *
   * <p>Use {@link #getMutableRunningCommands()} if you want to modify it.
   *
   * @return internal storage object for reading
   */
  public RepeatedMessage<ProtobufCommand> getRunningCommands() {
    return runningCommands;
  }

  /**
   * <code>repeated .wpi.proto.ProtobufCommand running_commands = 2;</code> This method returns the
   * internal storage object and sets the corresponding has state. The returned object will become
   * part of this message and its contents may be modified as long as the has state is not cleared.
   *
   * @return internal storage object for modifications
   */
  public RepeatedMessage<ProtobufCommand> getMutableRunningCommands() {
    bitField0_ |= 0x00000004;
    return runningCommands;
  }

  /**
   * <code>repeated .wpi.proto.ProtobufCommand running_commands = 2;</code>
   *
   * @param value the runningCommands to add
   * @return this
   */
  public ProtobufScheduler addRunningCommands(final ProtobufCommand value) {
    bitField0_ |= 0x00000004;
    runningCommands.add(value);
    return this;
  }

  /**
   * <code>repeated .wpi.proto.ProtobufCommand running_commands = 2;</code>
   *
   * @param values the runningCommands to add
   * @return this
   */
  public ProtobufScheduler addAllRunningCommands(final ProtobufCommand... values) {
    bitField0_ |= 0x00000004;
    runningCommands.addAll(values);
    return this;
  }

  @Override
  public ProtobufScheduler copyFrom(final ProtobufScheduler other) {
    cachedSize = other.cachedSize;
    if ((bitField0_ | other.bitField0_) != 0) {
      bitField0_ = other.bitField0_;
      lastTimeMs = other.lastTimeMs;
      queuedCommands.copyFrom(other.queuedCommands);
      runningCommands.copyFrom(other.runningCommands);
    }
    return this;
  }

  @Override
  public ProtobufScheduler mergeFrom(final ProtobufScheduler other) {
    if (other.isEmpty()) {
      return this;
    }
    cachedSize = -1;
    if (other.hasLastTimeMs()) {
      setLastTimeMs(other.lastTimeMs);
    }
    if (other.hasQueuedCommands()) {
      getMutableQueuedCommands().addAll(other.queuedCommands);
    }
    if (other.hasRunningCommands()) {
      getMutableRunningCommands().addAll(other.runningCommands);
    }
    return this;
  }

  @Override
  public ProtobufScheduler clear() {
    if (isEmpty()) {
      return this;
    }
    cachedSize = -1;
    bitField0_ = 0;
    lastTimeMs = 0D;
    queuedCommands.clear();
    runningCommands.clear();
    return this;
  }

  @Override
  public ProtobufScheduler clearQuick() {
    if (isEmpty()) {
      return this;
    }
    cachedSize = -1;
    bitField0_ = 0;
    queuedCommands.clearQuick();
    runningCommands.clearQuick();
    return this;
  }

  @Override
  public boolean equals(Object o) {
    if (o == this) {
      return true;
    }
    if (!(o instanceof ProtobufScheduler)) {
      return false;
    }
    ProtobufScheduler other = (ProtobufScheduler) o;
    return bitField0_ == other.bitField0_
        && (!hasLastTimeMs() || ProtoUtil.isEqual(lastTimeMs, other.lastTimeMs))
        && (!hasQueuedCommands() || queuedCommands.equals(other.queuedCommands))
        && (!hasRunningCommands() || runningCommands.equals(other.runningCommands));
  }

  @Override
  public void writeTo(final ProtoSink output) throws IOException {
    if ((bitField0_ & 0x00000001) != 0) {
      output.writeRawByte((byte) 25);
      output.writeDoubleNoTag(lastTimeMs);
    }
    if ((bitField0_ & 0x00000002) != 0) {
      for (int i = 0; i < queuedCommands.length(); i++) {
        output.writeRawByte((byte) 10);
        output.writeMessageNoTag(queuedCommands.get(i));
      }
    }
    if ((bitField0_ & 0x00000004) != 0) {
      for (int i = 0; i < runningCommands.length(); i++) {
        output.writeRawByte((byte) 18);
        output.writeMessageNoTag(runningCommands.get(i));
      }
    }
  }

  @Override
  protected int computeSerializedSize() {
    int size = 0;
    if ((bitField0_ & 0x00000001) != 0) {
      size += 9;
    }
    if ((bitField0_ & 0x00000002) != 0) {
      size +=
          (1 * queuedCommands.length()) + ProtoSink.computeRepeatedMessageSizeNoTag(queuedCommands);
    }
    if ((bitField0_ & 0x00000004) != 0) {
      size +=
          (1 * runningCommands.length())
              + ProtoSink.computeRepeatedMessageSizeNoTag(runningCommands);
    }
    return size;
  }

  @Override
  @SuppressWarnings("fallthrough")
  public ProtobufScheduler mergeFrom(final ProtoSource input) throws IOException {
    // Enabled Fall-Through Optimization (QuickBuffers)
    int tag = input.readTag();
    while (true) {
      switch (tag) {
        case 25:
          {
            // lastTimeMs
            lastTimeMs = input.readDouble();
            bitField0_ |= 0x00000001;
            tag = input.readTag();
            if (tag != 10) {
              break;
            }
          }
        case 10:
          {
            // queuedCommands
            tag = input.readRepeatedMessage(queuedCommands, tag);
            bitField0_ |= 0x00000002;
            if (tag != 18) {
              break;
            }
          }
        case 18:
          {
            // runningCommands
            tag = input.readRepeatedMessage(runningCommands, tag);
            bitField0_ |= 0x00000004;
            if (tag != 0) {
              break;
            }
          }
        case 0:
          {
            return this;
          }
        default:
          {
            if (!input.skipField(tag)) {
              return this;
            }
            tag = input.readTag();
            break;
          }
      }
    }
  }

  @Override
  public void writeTo(final JsonSink output) throws IOException {
    output.beginObject();
    if ((bitField0_ & 0x00000001) != 0) {
      output.writeDouble(FieldNames.lastTimeMs, lastTimeMs);
    }
    if ((bitField0_ & 0x00000002) != 0) {
      output.writeRepeatedMessage(FieldNames.queuedCommands, queuedCommands);
    }
    if ((bitField0_ & 0x00000004) != 0) {
      output.writeRepeatedMessage(FieldNames.runningCommands, runningCommands);
    }
    output.endObject();
  }

  @Override
  public ProtobufScheduler mergeFrom(final JsonSource input) throws IOException {
    if (!input.beginObject()) {
      return this;
    }
    while (!input.isAtEnd()) {
      switch (input.readFieldHash()) {
        case 1958056841:
        case -740797521:
          {
            if (input.isAtField(FieldNames.lastTimeMs)) {
              if (!input.trySkipNullValue()) {
                lastTimeMs = input.readDouble();
                bitField0_ |= 0x00000001;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
        case -167160549:
        case -1904270380:
          {
            if (input.isAtField(FieldNames.queuedCommands)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(queuedCommands);
                bitField0_ |= 0x00000002;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
        case -1719052953:
        case 1526672648:
          {
            if (input.isAtField(FieldNames.runningCommands)) {
              if (!input.trySkipNullValue()) {
                input.readRepeatedMessage(runningCommands);
                bitField0_ |= 0x00000004;
              }
            } else {
              input.skipUnknownField();
            }
            break;
          }
        default:
          {
            input.skipUnknownField();
            break;
          }
      }
    }
    input.endObject();
    return this;
  }

  @Override
  public ProtobufScheduler clone() {
    return new ProtobufScheduler().copyFrom(this);
  }

  @Override
  public boolean isEmpty() {
    return ((bitField0_) == 0);
  }

  public static ProtobufScheduler parseFrom(final byte[] data)
      throws InvalidProtocolBufferException {
    return ProtoMessage.mergeFrom(new ProtobufScheduler(), data).checkInitialized();
  }

  public static ProtobufScheduler parseFrom(final ProtoSource input) throws IOException {
    return ProtoMessage.mergeFrom(new ProtobufScheduler(), input).checkInitialized();
  }

  public static ProtobufScheduler parseFrom(final JsonSource input) throws IOException {
    return ProtoMessage.mergeFrom(new ProtobufScheduler(), input).checkInitialized();
  }

  /**
   * @return factory for creating ProtobufScheduler messages
   */
  public static MessageFactory<ProtobufScheduler> getFactory() {
    return ProtobufSchedulerFactory.INSTANCE;
  }

  /**
   * @return this type's descriptor.
   */
  public static Descriptors.Descriptor getDescriptor() {
    return Scheduler.wpi_proto_ProtobufScheduler_descriptor;
  }

  private enum ProtobufSchedulerFactory implements MessageFactory<ProtobufScheduler> {
    INSTANCE;

    @Override
    public ProtobufScheduler create() {
      return ProtobufScheduler.newInstance();
    }
  }

  /** Contains name constants used for serializing JSON */
  static class FieldNames {
    static final FieldName lastTimeMs = FieldName.forField("lastTimeMs", "last_time_ms");

    static final FieldName queuedCommands = FieldName.forField("queuedCommands", "queued_commands");

    static final FieldName runningCommands =
        FieldName.forField("runningCommands", "running_commands");
  }
}
